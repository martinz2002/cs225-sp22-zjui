\input{../template.tex}


\def\HWTITLE{Homework 5}
\def\COURSECODE{CS 225: Data Structures}
\def\AUTHOR{Group D1}


\begin{document}
\makeMyTitle
\thispagestyle{firstPage}

\begin{questions}

    \question{Zhong Tiantian}
    The list \texttt{next[]} must satisfy the following properties by definitions:
    \begin{enumerate}
        \item $\texttt{next[0]} = 0$, since the first element has no prefixes.
        \item $\texttt{next[$x$] = k}$ records the largest number $k_{max}$ that $ k_{max}\mbox{-prefix} = k_{max}\mbox{-postfix}$. For example, \texttt{next[$5$] $= 2$} indicates that the 5-th element in \texttt{pList[]} is equal to the 2-nd one.
    \end{enumerate}

    Obviously, this yields that $k$-prefix is equal to $k$-postfix.

    Assuming that we have known \texttt{next[0], next[1], ..., next[$x-1$]}, and denote \texttt{next[$x-1$]} as $now$:

    \begin{enumerate}
        \item If \texttt{pList[$x$] $=$ pList[$now$]}, which indicates the $now$-th element in \texttt{pList[]} is equal to the $x$-th, then extend the current sublist: \texttt{next[$x$]:=next[$x-1$]}.

        \item If \texttt{pList[$x$] $\neq$ pList[$now$]}, then go backward by reducing $now$ to \texttt{next[$now-1$]}.
    \end{enumerate}

    The algorithm is defined below.

    \begin{algorithm}
        \caption{Build \texttt{Next[]}}
        \label{alg-build-next}
        \SetKwArray{pList}{pList}
        \SetKwData{Next}{next}
        \SetKwData{Now}{now}
        \SetKwFunction{Append}{append}
        \SetKwFunction{Length}{getLength}
        \SetKw{Call}{call}

        \Next.\Append{$0$}

        $x \gets 1$

        $\Now \gets 0$

        \While{$x < \Length{\pList}$}{
            \If{$\pList{\Now} = \pList{x}$}{
                $\Now \gets \Now + 1$

                $x \gets x + 1$

                \Call \Next.\Append{\Now}

            }
            \ElseIf{$\Now \neq 0$}{\Now $\gets$ \Next{$\Now - 1$}}
            \Else{
                \Call \Next.\Append{$0$}

                $x \gets x + 1$
            }

        }
    \end{algorithm}

    \paragraph{Time Complexity Analysis}
    In most cases, the algorithm iterate one by one with $x\gets x + 1$, so it will perform \texttt{Length(pList)} times; in relatively rare cases, where $now$ goes backward, the extra time spent can be amortised to the general cases. Thus the amortised time complexity is $O(\mbox{\texttt{length(pList)}}) = O(m)$.

    \question{Jiang Wenhan}
    \paragraph{Algorithm Description}Assume the length of pattern sequence is $m$.
    \begin{itemize}
        \item Calculate the next sequence of the pattern sequence, which takes time $O(m)$, $m<n$ and align $P[0]$ and $S[0]$.
        \item Begin comparison between $P[0]$ and $S[0]$, if $P[0]\neq S[0]$.
        \item Turn back to $S[1]$, and keep doing things above until we found $P[0]=S[k], k\leq n$ ,

              \textbf{Once we found such $k$,}
              \begin{enumerate}
                  \item Align $P[0] $ with $S[k]$ and keep comparing them until we found $P[a]\neq S[k+a]$.
                  \item Right shift the pattern sequence for $m-next[a]$ where front maximal common sublist overlap with the original position of back maximal common sublist.
                  \item Repeat the comparison at this new position (begin with $P[next[a]]$ and $S[k+a]$).
              \end{enumerate}

              \textbf{Whenever we found that $a = m$,}
              \begin{enumerate}
                  \item Record the position $k$ , where the pattern sequence has occur.
                  \item Right shift the pattern sequence by $m-next[m]$ and start new comparison at $P[next[m]]$ and $S[k+m]$.
                  \item Repeat doing this until we reach the end, where the $P[m-1]$ is aligned with $S[n-1]$.
              \end{enumerate}
    \end{itemize}

    \paragraph{Time Complexity Analysis}To calculates its time complexity, we make an assumption of the worst case, where the pattern sequence and target sequence both consists of pairwise different elements. In such case, all elements in $next$ sequence are all $0$ . The times of shift is $\frac{n}{m}$, and the comparisons for each shift is $m$ , so the time complexity for comparison is $m\times\frac{n}{m} $, which is $n$. The total time complexity is $O(m)+n$ , since m is less equal than n, so the total time complexity is $O(n)$.

    \question{Zhou Ruidi}
    \begin{parts}
        \part
        \textbf{Method 1}
        
        Here is the algorithm.

        \begin{algorithm}
            \caption{Multiplying two polynomials.}
            \SetKwData{List}{list}

            \tcc{From $n_1$ to $n_d$ we choose one by one.}
            \tcc{Denote the length of the list as $d$.}

            \ForAll(calculate each number from $n_1$ to $n_d$){$n_i\in \List$ and $1\leq i \leq d$}{


                \For{$j = 2, 3, \cdots, d$}{

                    \tcc{calculate $P(n_i)$}

                    \For{$m = 2, 3, \cdots, j$}{
                        \tcc{figure out each element in the polynomial}

                        $n_i\gets n_i \cdot n_i$

                        \tcc{record this number, $k$ iterates from 2 to d, and we know that $a_d = 1$}

                        $P_k \gets a_k \cdot n_i$
                    }
                }
            }
        \end{algorithm}

        Calculate $P(n_i)$ by adding up the $P_k+a_0+a_1\cdot n_i$, and finally each $P(n_i)=0$. After that we can calculate the unknown coefficients $a_0, a_1, \cdots, a_{d-1}$. And the time complexity is $O(d\cdot d \cdot(d+1)/2) \approx O(d^3)$.

\vspace{1.5cm}

        \textbf{Method 2}

        For monic polynomial, it has the form like: $P(x)=(x-n_1) \cdot (x-n_2)\cdots (x-n_d)$  (because $a_d=1$) .

        We pair two elements to make one pair and we will get $d/2$ pairs: $(x-n_1)\cdot(x-n_2), (x-n_3)\cdot(x-n_4)$... and the time complexity for calculate each pair is $O(1)$ from the function before we know (Multiplying polynomials of degree $i$ and degree 1 has time complexity $O(i)$).

        Then we pair these $d/2$ polynomials to get $d/4$ polynomials and for each polynomial we spend $2\log 2$ using the function above (Degree-$i$ polynomial multiplying the degree-$i$ need $O(i\log i)$ . So for this step we need $(d/4)\cdot(2\log 2)$

        Repeat the above steps until getting the answer by multiplying two polynomials or three polynomials. The total time we need is
        % \[
        %     \sum_i \frac{1}{2^i} \cdot 2^{i-1}$\cdot \log(2^{i-1})= \frac{d}{2}(1+\log(2)+\log(4)+...)=\frac{d}{2}(\log d)^2
        % \]


        \begin{align*}
            \sum_{i} \frac{d}{2^i} \cdot 2^{i-1} \cdot \log 2^{i-1} & = \frac{d}{2}(1+\log 2+\log 4+...) \\
                                                                    & =\frac{d}{2}(\log d)^2             \\
                                                                    & \approx O(d\log^2 d)
        \end{align*}

        \part
        By \textbf{Method 2}, we know the answer is $(n/2)*(log(n))^2$.
    \end{parts}
\end{questions}

\end{document}