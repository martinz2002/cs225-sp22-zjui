\input{../template.tex}


\def\HWTITLE{Homework 2}
\def\COURSECODE{CS 225: Data Structures}
\def\AUTHOR{Group D1}


\begin{document}
\makeMyTitle
\thispagestyle{firstPage}


\begin{questions}

    \question
    We define two operations: checking-in (happens at arrival date) and checking-out (happens at departure date). Let the priority of checking-out is higher than checking-in, if they happen on the same day. Then one single booking will contain a checking-in and a checking-out.

    In order to maximize the use rate of hotel rooms, we assume the hotel only handle with check-ins in the afternoon and departures in the morning (i.e. A departure always happens earlier than an arrival, if they are on the same date).

    \begin{algorithm}
        \caption{Hotel Room Check}
        \label{alg-htlRmChk}
        \SetKwData{NumRooms}{k}
        \SetKwData{NumBookings}{n}
        \SetKwData{Date}{date}
        \SetKwArray{Bookings}{bookings}
        \SetKwData{Arrs}{arrivalDate}
        \SetKwData{Deps}{departureDate}
        \SetKwData{Op}{operation}
        \SetKwData{Prop}{prop}
        \SetKwArray{SortedOps}{sortedOps}
        \SetKwFunction{Sort}{Sort}
        \SetKwData{RoomCnt}{numInUse}
        \SetKwFunction{Print}{print}

        \tcc{NOTE: \Sort is a modified version of QuickSort, sorting the operation with the two criteria: 1. from earlier date to later; 2. on the same day, arrivals are put after departures.}
        \tcc{It outputs a list of operations with a member \Prop indicating whether the operation is arrival or departure. This tagging process is also completed in \Sort.}

        \If{$k\leq 0$}{\Print{``Bad Hotel!!!!!! GIVE MY MONEY BACK!!!!!!''}}

        \SortedOps $\gets$ \Sort{\Bookings.\Arrs, \Bookings.\Deps}

        \ForEach{\Op{$i$} in \SortedOps}{
            \If{$\Op{i}.\Prop = arrival$}{
                \If{$\RoomCnt = k$}{

                    \Print{``Insufficient Rooms!''}

                    Exit Algorithm}
                \Else{$\RoomCnt = \RoomCnt + 1$}
            }
            \Else{
                \If{\RoomCnt $=$ 0}
                {
                    \Print{``Bad testing engineer! I will fire you!''}
                    
                     Exit Algorithm
                }
            $\RoomCnt = \RoomCnt - 1$}
        }

        \Print{``Sufficient Room! Good Hotel! Rate you 5 stars \includegraphics[width=1cm]{mua.png}''}



    \end{algorithm}

    By sorting them respectively, we can generate a sequence of operation. Perform it operation by operation and trace the number of rooms in use on each day. If the number exceeds the largest capacity $k$-rooms, then the demands cannot be satisfied. Otherwise they will be satisfied.

    The algorithm is described in Algorithm \ref{alg-htlRmChk}.

    \question
    \begin{parts}
        \part
        % The following part is auto-generated by PanDoc from Wenhan's Markâ†‘.
        Firstly set \(x\) equals to \(e_i'\) , then
        \(\prod_{i=1}^{n}(x-e_i')\) should be equal to zero. If \(P(x)\) equals
        to zero, then the value of \(\prod_{i=1}^{n}(x-e_i)\) should be zero as
        well, which means there is one item in \([e_1,...,e_{ni}]\) whose value
        is equal to \(e_i'\) . Apply this method repeatedly for \(x\) from
        \(e_1'\) to \(e_{ni}'\) , we can obtain the conclusion that if the
        polynomial holds for \([e_1',...,e_{ni}']\), then \([e_1,...,e_{ni}]\)
        is a permutation of it.

        We can do the same things for \([e_1,...,e_{ni}]\), which provides the
        conclusion that \([e_1',...,e_{ni}']\) is the permutation of
        \([e_1,...,e_{ni}]\). To sum up, the condition that this polynomial
        holds, is the necessary sufficient condition.

        \part
        \(p-1\) should be larger or equal than \(e_{ni}\) and \(n\), assume
        the largest value among \([e_1,...,e_{ni},e_1',...,e_{ni}']\) is
        \(e_{ni}\) . To ensure \(P(x)\mod{p}\equiv 0\), the value of \(x\),
        \(e_i\), \(e_{i}'\) should be the same. since \([e_1,...,e_{ni}]\) is
        not the permutation of \([e_1',...,e_{ni}']\) , the values that \(e_n\)
        equals to \(e_n'\) is less than the number of he items in
        \([e_1,...,e_{ni}]\). Besides, \(x\) is less than \(p-1\). So, the
        possibility \(K\) that the result of evaluation is zero is less than
        \(\frac{n}{p-1}\).

        Meanwhile, \(p-1\) should be also larger than \(\frac{n}{\epsilon}\),
        which shows \(\epsilon\geq\frac{n}{p-1}\). To sum up, the possibility
        \(K\) is at most \(\epsilon\)
    \end{parts}



    \question
    \begin{parts}
        \part
        Denoting the original stack $S$, and the two additional stacks $S_1$ and $S_2$. The process can be described as Algorithm \ref{algo-reverse1}.
        \begin{algorithm}
            \caption{Reverse stack}
            \label{algo-reverse1}
            \SetKwFunction{Pop}{pop\_top}
            \SetKwFunction{Push}{push}
            \While{$S$ is not empty}{
                $S_1$.\Push{$S$.\Pop}
            }
            \While{$S_1$ is not empty}{
                $S_2$.\Push{$S_1$.\Pop}
            }
            \While{$S_2$ is not empty}{
                $S$.\Push{$S_2$.\Pop}
            }
        \end{algorithm}


        \part
        Denoting the original stack $S$, and the queue $Q$. The process can be described as Algorithm \ref{algo-reverse2}.
        \begin{algorithm}
            \caption{Reverse stack again}
            \label{algo-reverse2}
            \SetKwFunction{Pop}{pop\_top}
            \SetKwFunction{App}{append}
            \While{$S$ is not empty}{\
                $Q.\App{S.\Pop}$
            }
            \While{$Q$ is not empty}{
                $S.\Push{Q.\Pop}$
            }
        \end{algorithm}


        \part
        Assuming we have $N$ elements $\{e_1, e_2, \cdots, e_N\}$ and two stacks $S_A$ and $S_B$. The initial status of $S_A$ is denoted as $S_{A0}$. The elements $e_i (1\leq i \leq N)$ are placed in $S_A$ initially.

        The thing is, we try to copy $S_A$ into $S_B$ with the order of elements unchanged (making $S_{B}^\prime = S_{A0}$); and then by popping each element in $S_{B}^\prime$ out and pushing back in $S_A$, we make the top element of $S_{B}^\prime\prime$ the bottom one of the $S_A^\prime$, i.e. the $i$-th in $S_{B}^\prime$ becomes the $(n-i+1)$-th in $S_A^\prime$. Finally $S_A^\prime$ is the reversed from its original.

        Define an operation \ref{proc-move}, which one by one pops the top $(n-1)$ elements from $S_A$ and pushes them into $S_B$, and store the $n$-th element (the bottom one) in the extra variable \texttt{temp}. The operation is described in Procedure \ref{proc-move}.



        Before \ref{proc-move}($i-1$) is called, which indicates $i$ times of calling \ref{proc-move}, we will get the original stack with elements $\left[ e_1, \cdots, e_{i-1} \right]$ (from top to bottom) and the extra stack with $\left[ e_i, \cdots, e_n \right]$. Since a stack satisfies LIFO principle, and keep iterating and calling \ref{proc-move}($n$), \ref{proc-move}($n-1$), \dots, \ref{proc-move}($1$) we will finally get $S_B = S_{A0}$. Then pop all elements in $S_B^{\prime\prime}$ and push them back to $S_A^{\prime\prime}$, we obtain $S_A^{\prime\prime}$ is the reverse of $S_B^{\prime\prime}$, i.e. the reverse of $S_{A0}$.

        Algorithm \ref{algo-reverse} describes the whole operation.

        \begin{procedure}
            \caption{MOVE($n$)}
            \label{proc-move}
            \SetKwData{OrigStack}{OriginalStack}
            \SetKwData{ExStack}{ExtraStack}
            \SetKwData{ExVar}{ExtraVar}
            \SetKwFunction{Pop}{pop\_top}
            \SetKwFunction{Push}{push}
            \SetKwFunction{Numitem}{numitem}
            \tcc{Denoting $S_A$ as \OrigStack and $S_B$ \ExStack.}
            \tcc{We are to copy the front $n-1$ elements into \ExStack, reversely.}
            \tcc{Before \MOVE{$n$} is called, \OrigStack has $n$ elements.}

            \If(finishing stack copy from \OrigStack to \ExStack){$n=0$}{exit call}

            \While{\OrigStack is not empty}{
                \ExStack.\Push{\OrigStack.\Pop}
            }

            \tcc{Now we store the last element popped into \ExVar.}

            $\ExVar \gets \ExStack.\Pop$

            \While{$\ExStack.\Numitem > n$}{\OrigStack.\Push{\ExStack.\Pop}}

            Call \MOVE{$n-1$}
        \end{procedure}

        \begin{algorithm}
            \caption{Reverse the Stack}
            \label{algo-reverse}
            \SetKwData{OrigStack}{OriginalStack}
            \SetKwData{ExStack}{ExtraStack}
            \SetKwData{ExVar}{ExtraVar}
            \SetKwFunction{Pop}{pop\_top}
            \SetKwFunction{Push}{push}
            \SetKwFunction{Numitem}{numitem}
            \SetKwFunction{Move}{MOVE}
            \tcc{Denoting $S_A$ as \OrigStack and $S_B$ \ExStack.}

            $n\gets \OrigStack.\Numitem$

            Call \Move{n}

            \While{\ExStack is not empty}{
                \OrigStack.\Push{\ExStack.\Pop}
            }
        \end{algorithm}

    \end{parts}

\end{questions}
\end{document}